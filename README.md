# vMix Active Timecode Controller 애플리케이션 기획서

## 1. 프로젝트 개요

### 1.1. 프로젝트 명
vMix Active Timecode Controller

### 1.2. 프로젝트 목표
본 프로젝트는 현재 Jupyter Notebook 환경에서 개발된 vMix 연동 타임코드 관리 툴을, 실제 방송 환경에서 안정적으로 사용할 수 있는 독립 실행형(Standalone) 데스크톱 애플리케이션으로 재설계하고 개발하는 것을 목표로 한다. 최종 사용자는 파이썬이나 별도 라이브러리 설치 없이도 프로그램을 쉽게 실행하고 사용할 수 있어야 한다.

### 1.3. 현황 및 문제점
- **플랫폼 의존성**: Jupyter Notebook(.ipynb) 파일 형태로 존재하여, 실행을 위해 Jupyter 환경이 필수적이다. 이는 일반 사용자에게 배포하기 어렵고 시스템 리소스를 불필요하게 차지한다.
- **모놀리식 구조**: UI, 비즈니스 로직(GTO-W 검사 등), 네트워크 통신, 상태 관리가 단일 파일에 모두 혼재되어 있다. 이는 코드의 가독성을 저해하고, 작은 수정이 예상치 못한 버그를 유발할 수 있는 잠재적 위험을 내포한다(낮은 유지보수성).
- **배포의 어려움**: 최종 사용자가 직접 소스 코드를 실행해야 하므로 배포 및 설치 과정이 복잡하다.

### 1.4. 개선 방향
- **독립 실행형 애플리케이션**: PyInstaller 등의 패키징 도구를 사용하여 Python이 설치되지 않은 환경에서도 실행 가능한 단일 `.exe` 파일로 배포한다.
- **아키텍처 도입**: UI(View)와 로직(Model/Controller)을 명확히 분리하는 MVC(Model-View-Controller) 패턴을 적용하여 코드의 결합도를 낮추고, 유지보수성과 안정성을 향상시킨다.
- **프로젝트 구조화**: 기능별로 소스 코드를 모듈화하고 체계적인 폴더 구조를 도입하여 관리 효율성을 높인다.

---

## 2. 기능 명세

### 2.1. 핵심 기능 (As-is)
기존 `.ipynb` 파일에 구현된 모든 기능을 계승하고 안정화한다.

| 기능 분류 | 상세 기능 |
| --- | --- |
| **vMix 연동** | - 주/보조 vMix 서버 IP 및 이름 설정<br>- vMix API를 통한 실시간 데이터(타임코드, 인풋 정보) 수신<br>- vMix로 명령어(Function) 전송 |
| **타임코드 레일 관리** | - 다중 레일(Line) 인터페이스 제공<br>- 각 레일별 시간, 프리뷰, 버튼, 코멘트, 인풋 번호 설정<br>- 레일별 실행(Run)/정지(Stop) 기능 및 상태 표시 |
| **실시간 표시** | - 메인 vMix의 현재 타임코드를 대형 폰트로 실시간 표시<br>- vMix 연결 상태 및 기타 상태를 시각적(원형 아이콘)으로 표시 |
| **GTO-W 감시 모드** | - '방송 진행용'과 'GTO-W 감시용' 두 가지 동작 모드 제공<br>- GTO-W 모드에서 특정 규칙(10가지)에 따라 레일 계획의 유효성을 자동 검사<br>- 유효성 검사 결과(성공/실패)를 레일 배경색으로 즉시 피드백 |
| **설정 관리** | - 모든 설정(IP, 레일 데이터, 단축키 등)을 `settings.json` 파일로 저장 및 불러오기 |
| **사용자 편의 기능** | - 키보드를 이용한 위젯 간 상/하/좌/우 내비게이션<br>- 타임코드 입력 필드 자동 완성 및 증감 기능<br>- 전역 단축키(Hotkey) 지원 |

### 2.2. 추가 제안 기능 (To-be)
- **중앙 로깅 시스템**: 모든 이벤트와 오류를 타임스탬프와 함께 파일(`app.log`)로 기록하여 문제 발생 시 원인 추적이 용이하도록 개선한다.
- **프로필 관리**: 여러 개의 방송 환경 설정(vMix IP, 레일 구성 등)을 별도의 프로필로 저장하고 쉽게 전환할 수 있는 기능을 추가한다.
- **UI 테마**: 라이트/다크 모드 등 간단한 UI 테마 변경 기능을 제공하여 사용자 편의성을 높인다.

---

## 3. 기술 스택 및 아키텍처

### 3.1. 언어 및 프레임워크
- **언어**: Python 3.x
- **UI 프레임워크**: Tkinter (기존 코드베이스 활용)

### 3.2. 주요 라이브러리
- **네트워크**: `requests`
- **이미지 처리**: `Pillow`
- **키보드/클립보드**: `keyboard`, `pyperclip`
- **패키징**: `PyInstaller`

### 3.3. 제안 아키텍처: MVC (Model-View-Controller)
- **Model**: 애플리케이션의 데이터와 상태를 관리.
  - `Settings`: `settings.json` 파일의 로드/저장 담당.
  - `LineDataModel`: 레일(Line) 데이터 관리.
  - `VmixState`: vMix 연결 상태 및 실시간 데이터 관리.
- **View**: 사용자 인터페이스(UI)를 담당.
  - `ActiveTimecodeApp`: Tkinter 위젯 생성, 배치 및 UI 업데이트. Model의 데이터를 기반으로 화면을 그림.
- **Controller**: 사용자의 입력(버튼 클릭, 키보드 입력)을 받아 로직을 처리하고, Model과 View를 제어.
  - `AppController`: 이벤트 핸들러, GTO-W 유효성 검사 로직 호출, vMix API 연동 로직 실행.

![MVC Architecture](https://i.imgur.com/O8t4B2A.png)

### 3.4. 프로젝트 구조
```
vMixTimecodeApp/
├── dist/                  # PyInstaller 빌드 결과물 (exe 파일)
├── src/
│   ├── __init__.py
│   ├── view/
│   │   ├── __init__.py
│   │   ├── app_view.py      # 메인 윈도우 및 UI 구성 (View)
│   │   └── ui_utils.py      # StatusCircleBar 등 UI 헬퍼
│   ├── model/
│   │   ├── __init__.py
│   │   └── settings.py      # 설정 및 데이터 관리 (Model)
│   ├── controller/
│   │   ├── __init__.py
│   │   ├── app_controller.py # 이벤트 처리 및 로직 제어 (Controller)
│   │   └── gto_logic.py      # GTO-W 유효성 검사 로직
│   └── assets/              # 아이콘 등 리소스 파일
├── main.py                  # 애플리케이션 시작점
├── requirements.txt         # 의존성 목록
└── app.log                  # 로그 파일
```

---

## 4. 개발 로드맵

### Phase 1: 기반 다지기 (1주) - 완료
- **Task 1**: `.ipynb` 코드를 `.py` 파일로 변환. (완료)
- **Task 2**: 제안된 프로젝트 폴더 구조 생성. (완료)
- **Task 3**: 기능별로 코드를 각 모듈 파일로 분리 (e.g., `gto_logic.py`, `settings.py` 분리). (완료)
- **Task 4**: `requirements.txt` 파일 작성 및 의존성 관리 체계화. (완료)
- **Milestone**: Jupyter Notebook 없이 `python main.py`로 앱이 실행되는 상태. (달성)

### Phase 2: 아키텍처 리팩토링 (2주)
- **Task 1**: MVC 패턴 적용 시작. `AppView`, `AppController` 클래스 구조 설계.
- **Task 2**: 데이터 관리 로직을 `model` 패키지로 이전.
- **Task 3**: UI 이벤트 핸들러 로직을 `AppController`로 이전하여 View와 로직 분리.
- **Task 4**: 중앙 로깅 시스템(`logging` 모듈) 도입.
- **Milestone**: UI와 비즈니스 로직이 분리되어 코드 수정 및 테스트가 용이해진 상태.

### Phase 3: 최적화 및 배포 (1주)
- **Task 1**: 네트워크 통신 등 블로킹(Blocking)이 발생할 수 있는 부분에 `asyncio` 또는 `threading`을 적용하여 UI 반응성 개선 검토.
- **Task 2**: `PyInstaller`를 사용하여 `.spec` 파일을 설정하고, 단일 실행 파일(.exe) 빌드 스크립트 작성.
- **Task 3**: 아이콘 등 리소스 파일을 실행 파일에 포함시키는 작업.
- **Milestone**: 모든 기능이 포함된 독립 실행형 `.exe` 파일 완성.

---

## 5. 기대 효과
- **안정성**: 명확한 아키텍처와 중앙화된 오류 처리로 런타임 오류 및 상태 충돌 가능성을 최소화.
- **유지보수성**: 기능별 모듈화로 특정 기능의 수정 및 추가가 용이해지며, 다른 기능에 미치는 영향을 최소화.
- **사용 편의성**: 별도의 설치 과정 없이 단일 파일로 프로그램을 실행할 수 있어 사용자 접근성이 크게 향상.
- **확장성**: 견고한 구조를 기반으로 향후 프로필 관리, 테마 적용 등 새로운 기능을 안정적으로 추가할 수 있는 토대 마련.
